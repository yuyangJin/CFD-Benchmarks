#ifndef __UTIL_H
#define __UTIL_H

#include <sys/time.h>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <unordered_map>

// #define ENO_FUSION
// #define MUSCL_FUSION
// #define ROE_FUSION
// #define UPWINDTVD_FUSION
// #define SYMTVD_FUSION
// #define NND_FUSION
// #define WENO_FUSION
// #define COMPACT_FUSION

#define GAMA 1.4
#define PI 3.1415926
#define Lx 4.0
#define Ly 1.0
#define TT 0.1
#define Nx 400
#define Ny 100
#define XPOS 0.6
#define YPOS 0.2 

#define ROECFL 0.4
#define MUSCLCFL 0.4
#define UPWINDTVDCFL 0.4
#define SYMTVDCFL 0.3
#define NNDCFL 0.4
#define ENOCFL 0.1
#define WENOCFL 0.2
#define COMPACTCFL 0.1

#define MIN(x, y) (((x) < (y)) ? (x) : (y))
#define MAX(x, y) (((x) > (y)) ? (x) : (y))

#define get_elapsed_time_ms(_s, _e) (1000.0 * (_e.tv_sec - _s.tv_sec) + (_e.tv_usec - _s.tv_usec) / 1000.0)


void save(const char* fn, double U[Nx + 7][Ny + 7][4]) {
  std::ofstream out;
  out.open(fn, std::ofstream::binary);
  out.write(reinterpret_cast<const char*>(U), sizeof(double) * (Nx + 7) * (Ny + 7) * 4);
  out.close();
}

void check(const char* fn, double U[Nx + 7][Ny + 7][4]) {
  double U_dat[Nx + 7][Ny + 7][4];
  std::ifstream in;
  in.open(fn, std::ifstream::binary);
  in.read(reinterpret_cast<char*>(U_dat), sizeof(double) * (Nx + 7) * (Ny + 7) * 4);
  in.close();
  for (int i = 0; i < Nx + 7; ++i) {
    for (int j = 0; j < Ny + 7; ++j) {
      for (int k = 0; k < 4; ++k) {
        if (fabs(U_dat[i][j][k] - U[i][j][k]) >= 1e-6) {
          printf("CHECK FAILED (%lf != %lf)\n", U_dat[i][j][k], U[i][j][k]);
          return;
        }
      }
    }
  }
  printf("CHECK PASS\n");
}

//初始化函数
//作用:将全场赋初值
void initial(double U[Nx + 7][Ny + 7][4], double& dx, double& dy) {
  int i, j;
  dx = Lx / Nx;
  dy = Ly / Ny;
  double rou1 = 1, u1 = 0, v1 = 0, a1 = 1, p1 = 0.71429;
  double rou2 = 3.85714, p2 = 7.381, u2 = 2.22223, v2 = 0;
  for (i = 0; i <= Nx + 6; i++)  //初始条件  这里先把所有区域都赋值u1 v1 p1 rou1
    for (j = 0; j <= Ny + 6; j++) {
      U[i][j][0] = rou1;
      U[i][j][1] = rou1 * u1;
      U[i][j][2] = rou1 * v1;
      U[i][j][3] = p1 / (GAMA - 1) + 0.5 * rou1 * (u1 * u1 + v1 * v1);
    }
  //边界以外赋零
  for (i = 0; i <= int(1.0 / dx) - 1; i++)
    for (j = int(0.5 / dy) + 7; j <= Ny + 6; j++) {
      U[i][j][0] = 0;
      U[i][j][1] = 0;
      U[i][j][2] = 0;
      U[i][j][3] = 0;
    }
  for (i = int(2.0 / dx) + 7; i <= Nx + 6; i++)
    for (j = int(0.5 / dy) + 7; j <= Ny + 6; j++) {
      U[i][j][0] = 0;
      U[i][j][1] = 0;
      U[i][j][2] = 0;
      U[i][j][3] = 0;
    }
}

// CFL稳定性条件
//入口:U(没有进行过Roe平均的U向量)
//出口:dt
double CFL(double U[Nx + 7][Ny + 7][4], double dx, double dy, double cfl) {
  int i, j;
  double u, v, rou, a, vel, maxvel, p;
  maxvel = 1e-100;
  for (i = 0; i <= Nx + 6; i++)
    for (j = 0; j <= Ny + 6; j++)
      if (U[i][j][0] != 0) {
        rou = U[i][j][0];
        u = U[i][j][1] / U[i][j][0];
        v = U[i][j][2] / U[i][j][0];
        p = (GAMA - 1) * (U[i][j][3] - 0.5 * rou * (u * u + v * v));
        a = sqrt(p * GAMA / rou);
        vel = a + fabs(u);
        if (vel >= maxvel) maxvel = vel;
        vel = a + fabs(v);
        if (vel >= maxvel) maxvel = vel;
      }
  return cfl * MIN(dx, dy) / maxvel;
}

// CFL_稳定性条件
//入口:U_是进行了Roe平均的向量),a_是声速
//出口:dt
double CFL_(double U_[Nx + 7][Ny + 7][4], double a_[Nx + 7][Ny + 7][1], double dx, double dy, double cfl) {
  int i, j;
  double u, v, rou, a, vel, maxvel;
  maxvel = 1e-100;
  for (i = 0; i <= Nx + 6; i++)
    for (j = 0; j <= Ny + 6; j++)
      if (U_[i][j][0] != 0) {
        rou = U_[i][j][0];
        u = U_[i][j][1];
        v = U_[i][j][2];
        a = a_[i][j][0];
        vel = a + sqrt(u * u + v * v);
        if (vel >= maxvel) maxvel = vel;
      }
  return cfl * MIN(dx, dy) / maxvel;
}

//边界函数
//入口:U
//出口:无
//作用:将左右边界以及虚拟节点赋值,并且处理特殊的凹凸角点以及虚拟节点,另外对边界上面的法相速度强制赋零
void bound_1(double U[Nx + 7][Ny + 7][4], double dx, double dy) {
  int i, j, k;
  double rou1 = 1, u1 = 0, v1 = 0, a1 = 1, p1 = 0.71429;
  double rou2 = 3.85714, p2 = 7.381, u2 = 2.22223, v2 = 0;
  for (i = 0; i <= 2; i++)  //左边界条件
    for (j = 0; j <= int(0.5 / dy) + 6; j++) {
      U[i][j][0] = rou2;
      U[i][j][1] = rou2 * u2;
      U[i][j][2] = rou2 * v2;
      U[i][j][3] = p2 / (GAMA - 1) + 0.5 * rou2 * (u2 * u2 + v2 * v2);
    }
  for (i = Nx + 4; i <= Nx + 6; i++)  //右边界条件
    for (j = 0; j <= int(0.5 / dy) + 6; j++) {
      U[i][j][0] = U[i - 1][j][0];
      U[i][j][1] = U[i - 1][j][1];
      U[i][j][2] = U[i - 1][j][2];
      U[i][j][3] = U[i - 1][j][3];
    }
  for (i = 3; i <= Nx + 3; i++)  //虚拟节点的处理,这里采用镜面反射,标量和切向速度取相同值,法相速度取相反值
    for (j = 0; j <= 2; j++) {
      U[i][j][0] = U[i][6 - j][0];
      U[i][j][1] = U[i][6 - j][1];
      U[i][j][2] = -U[i][6 - j][2];
      U[i][j][3] = U[i][6 - j][3];
    }
  for (i = 3; i <= int(1.0 / dx) + 2; i++)
    for (j = int(0.5 / dy) + 4; j <= int(0.5 / dy) + 6; j++) {
      U[i][j][0] = U[i][-j + 2 * int(0.5 / dy) + 6][0];
      U[i][j][1] = U[i][-j + 2 * int(0.5 / dy) + 6][1];
      U[i][j][2] = -U[i][-j + 2 * int(0.5 / dy) + 6][2];
      U[i][j][3] = U[i][-j + 2 * int(0.5 / dy) + 6][3];
    }
  for (i = int(1.0 / dx); i <= int(2.0 / dx) + 6; i++)
    for (j = Ny + 4; j <= Ny + 6; j++) {
      U[i][j][0] = U[i][-j + 2 * int(1.0 / dy) + 6][0];
      U[i][j][1] = U[i][-j + 2 * int(1.0 / dy) + 6][1];
      U[i][j][2] = -U[i][-j + 2 * int(1.0 / dy) + 6][2];
      U[i][j][3] = U[i][-j + 2 * int(1.0 / dy) + 6][3];
    }
  for (i = int(2.0 / dx) + 4; i <= Nx + 3; i++)
    for (j = int(0.5 / dy) + 4; j <= int(0.5 / dy) + 6; j++) {
      U[i][j][0] = U[i][-j + 2 * int(0.5 / dy) + 6][0];
      U[i][j][1] = U[i][-j + 2 * int(0.5 / dy) + 6][1];
      U[i][j][2] = -U[i][-j + 2 * int(0.5 / dy) + 6][2];
      U[i][j][3] = U[i][-j + 2 * int(0.5 / dy) + 6][3];
    }
  for (i = int(1.0 / dx); i <= int(1.0 / dx) + 2; i++)
    for (j = int(0.5 / dy) + 4; j <= Ny + 6; j++) {
      U[i][j][0] = U[2 * int(1.0 / dx) + 6 - i][j][0];
      U[i][j][1] = -U[2 * int(1.0 / dx) + 6 - i][j][1];
      U[i][j][2] = U[2 * int(1.0 / dx) + 6 - i][j][2];
      U[i][j][3] = U[2 * int(1.0 / dx) + 6 - i][j][3];
    }
  for (i = int(2.0 / dx) + 4; i <= int(2.0 / dx) + 6; i++)
    for (j = int(0.5 / dy) + 4; j <= Ny + 6; j++) {
      U[i][j][0] = U[2 * int(2.0 / dx) + 6 - i][j][0];
      U[i][j][1] = -U[2 * int(2.0 / dx) + 6 - i][j][1];
      U[i][j][2] = U[2 * int(2.0 / dx) + 6 - i][j][2];
      U[i][j][3] = U[2 * int(2.0 / dx) + 6 - i][j][3];
    }
  //角点的虚拟网格特殊处理
  int a, b;
  a = int(1.0 / dx) + 2;  //角凸点(a,b)以及其附近虚拟节点处理,处理方法参考了教材相关内容
  b = int(0.5 / dy) + 4;
  for (k = 0; k <= 3; k++) {
    U[a][b][k] = 0.5 * (U[a][b - 2][k] + U[a + 2][b][k]);
    U[a - 1][b][k] = U[a - 1][b - 2][k];
    U[a - 2][b][k] = U[a - 2][b - 2][k];
    U[a][b + 1][k] = U[a + 2][b + 1][k];
    U[a][b + 2][k] = U[a + 2][b + 2][k];
    U[a - 1][b + 1][k] = 0.5 * (U[a - 1][b - 3][k] + U[a + 3][b + 1][k]);
    U[a - 2][b + 1][k] = U[a - 2][b - 3][k];
    U[a - 1][b + 2][k] = U[a + 3][b + 2][k];
    U[a - 2][b + 2][k] = 0.5 * (U[a - 2][b - 4][k] + U[a + 4][b + 2][k]);
  }
  U[a - 1][b][2] = -U[a - 1][b - 2][2];
  U[a - 2][b][2] = -U[a - 2][b - 2][2];
  U[a - 2][b + 1][2] = -U[a - 2][b - 3][2];
  U[a][b + 1][1] = -U[a + 2][b + 1][1];
  U[a][b + 2][1] = -U[a + 2][b + 2][1];
  U[a - 1][b + 2][1] = -U[a + 3][b + 2][1];
  a = int(2.0 / dx) + 4;
  b = int(0.5 / dy) + 4;
  for (k = 0; k <= 3; k++) {
    U[a][b][k] = 0.5 * (U[a][b - 2][k] + U[a - 2][b][k]);
    U[a + 1][b][k] = U[a + 1][b - 2][k];
    U[a + 2][b][k] = U[a + 2][b - 2][k];
    U[a][b + 1][k] = U[a - 2][b + 1][k];
    U[a][b + 2][k] = U[a - 2][b + 2][k];
    U[a + 1][b + 1][k] = 0.5 * (U[a + 1][b - 3][k] + U[a - 3][b + 1][k]);
    U[a + 2][b + 1][k] = U[a + 2][b - 3][k];
    U[a + 1][b + 2][k] = U[a - 3][b + 2][k];
    U[a + 2][b + 2][k] = 0.5 * (U[a + 2][b - 4][k] + U[a - 4][b + 2][k]);
  }
  U[a + 1][b][2] = -U[a + 1][b - 2][2];
  U[a + 2][b][2] = -U[a + 2][b - 2][2];
  U[a + 2][b + 1][2] = -U[a + 2][b - 3][2];
  U[a][b + 1][1] = -U[a - 2][b + 1][1];
  U[a][b + 2][1] = -U[a - 2][b + 2][1];
  U[a + 1][b + 2][1] = -U[a - 3][b + 2][1];
  //边界上强行赋法向为零
  for (i = 3; i <= Nx + 3; i++) {
    U[i][3][2] = 0;
  }
  for (i = 3; i <= int(1.0 / dx) + 2; i++) {
    U[i][int(0.5 / dy) + 3][2] = 0;
  }
  for (i = int(2.0 / dx) + 4; i <= Nx + 3; i++) {
    U[i][int(0.5 / dy) + 3][2] = 0;
  }
  for (i = int(1.0 / dx) + 3; i <= int(2.0 / dx) + 3; i++) {
    U[i][Ny + 3][2] = 0;
  }
  for (j = int(0.5 / dy) + 4; j <= Ny + 3; j++) {
    U[int(1.0 / dx) + 3][j][1] = 0;
  }
  for (j = int(0.5 / dy) + 4; j <= Ny + 3; j++) {
    U[int(2.0 / dx) + 3][j][1] = 0;
  }
}

// WENO
/////边界条件函数（含角点）
void bound_2(double U[Nx + 7][Ny + 7][4], double dx, double dy) {
  int i, j, k;
  double rou1 = 1.0, u1 = 0, v1 = 0, p1 = 0.71429, Ms = 5;
  double rou2, u2, v2, p2;

  //波后参数
  rou2 = rou1 * Ms * Ms / (1 + (GAMA - 1) / (GAMA + 1) * (Ms * Ms - 1));
  u2 = 2 / (GAMA + 1) * (Ms - 1 / Ms) * sqrt(GAMA * p1 / rou1);
  v2 = 0;
  p2 = p1 * (1 + 2 * GAMA / (GAMA + 1) * (Ms * Ms - 1));

  //左边界
  for (i = 0; i <= 2; i++)
    for (j = 2; j <= Ny + 2; j++) {
      U[i][j][0] = rou2;
      U[i][j][1] = rou2 * u2;
      U[i][j][2] = 0;
      U[i][j][3] = p2 / (GAMA - 1) + 0.5 * rou2 * (u2 * u2 + v2 * v2);
    }
  //右边界
  for (i = Nx + 3; i <= Nx + 4; i++)
    for (j = 2; j <= Ny + 2; j++)
      for (k = 0; k <= 3; k++) U[i][j][k] = U[Nx + 2][j][k];

  //固壁边界法向速度为零
  // X方向线段
  for (i = 0; i <= Nx + 4; i++) {
    U[i][Ny + 2][2] = 0;
    U[i][2][2] = 0;
  }
  for (i = Nx / 6 + 3; i <= Nx / 3 + 1; i++) U[i][Ny / 4 + 2][2] = 0;
  for (i = Nx / 2 + 3; i <= Nx * 2 / 3 + 1; i++) U[i][Ny * 3 / 4 + 2][2] = 0;

  // y方向线段
  for (j = Ny * 3 / 4 + 3; j <= Ny + 2; j++) {
    U[Nx / 2 + 2][j][1] = 0;
    U[Nx * 2 / 3 + 2][j][1] = 0;
  }
  for (j = 2; j <= Ny / 4 + 1; j++) {
    U[Nx / 6 + 2][j][1] = 0;
    U[Nx / 3 + 2][j][1] = 0;
  }

  //虚拟边界的镜像处理
  //上边界
  for (j = Ny * 3 / 4 + 5; j <= Ny + 2; j++)  //第二段 //
    for (i = Nx / 2 + 3; i <= Nx / 2 + 4; i++) {
      U[i][j][0] = U[Nx + 4 - i][j][0];
      U[i][j][1] = -U[Nx + 4 - i][j][1];
      U[i][j][2] = U[Nx + 4 - i][j][2];
      U[i][j][3] = U[Nx + 4 - i][j][3];
    }

  for (i = Nx / 2 + 5; i <= Nx * 2 / 3 - 1; i++)  //第三段
    for (j = Ny * 3 / 4 + 3; j <= Ny * 3 / 4 + 4; j++) {
      U[i][j][0] = U[i][Ny * 3 / 2 + 4 - j][0];
      U[i][j][1] = U[i][Ny * 3 / 2 + 4 - j][1];
      U[i][j][2] = -U[i][Ny * 3 / 2 + 4 - j][2];
      U[i][j][3] = U[i][Ny * 3 / 2 + 4 - j][3];
    }

  for (j = Ny * 3 / 4 + 5; j <= Ny + 2; j++)  //第四段 //
    for (i = Nx * 2 / 3; i <= Nx * 2 / 3 + 1; i++) {
      U[i][j][0] = U[Nx * 4 / 3 + 4 - i][j][0];
      U[i][j][1] = -U[Nx * 4 / 3 + 4 - i][j][1];
      U[i][j][2] = U[Nx * 4 / 3 + 4 - i][j][2];
      U[i][j][3] = U[Nx * 4 / 3 + 4 - i][j][3];
    }

  for (i = 0; i <= Nx + 4; i++)  //第一段//
    for (j = Ny + 3; j <= Ny + 4; j++) {
      U[i][j][0] = U[i][2 * Ny + 4 - j][0];
      U[i][j][1] = U[i][2 * Ny + 4 - j][1];
      U[i][j][2] = -U[i][2 * Ny + 4 - j][2];
      U[i][j][3] = U[i][2 * Ny + 4 - j][3];
    }

  //下边界
  for (j = 2; j <= Ny / 4 - 1; j++)  //第二段 /
    for (i = Nx / 6 + 3; i <= Nx / 6 + 4; i++) {
      U[i][j][0] = U[Nx / 3 + 4 - i][j][0];
      U[i][j][1] = -U[Nx / 3 + 4 - i][j][1];
      U[i][j][2] = U[Nx / 3 + 4 - i][j][2];
      U[i][j][3] = U[Nx / 3 + 4 - i][j][3];
    }
  for (i = Nx / 6 + 5; i <= Nx / 3 - 1; i++)  //第三段
    for (j = Ny / 4; j <= Ny / 4 + 1; j++) {
      U[i][j][0] = U[i][Ny / 2 + 4 - j][0];
      U[i][j][1] = U[i][Ny / 2 + 4 - j][1];
      U[i][j][2] = -U[i][Ny / 2 + 4 - j][2];
      U[i][j][3] = U[i][Ny / 2 + 4 - j][3];
    }
  for (j = 2; j <= Ny / 4 - 1; j++)  //第四段
    for (i = Nx / 3; i <= Nx / 3 + 1; i++) {
      U[i][j][0] = U[Nx * 2 / 3 + 4 - i][j][0];
      U[i][j][1] = -U[Nx * 2 / 3 + 4 - i][j][1];
      U[i][j][2] = U[Nx * 2 / 3 + 4 - i][j][2];
      U[i][j][3] = U[Nx * 2 / 3 + 4 - i][j][3];
    }

  for (i = 0; i <= Nx + 4; i++)  //第一段
    for (j = 0; j <= 1; j++) {
      U[i][j][0] = U[i][4 - j][0];
      U[i][j][1] = U[i][4 - j][1];
      U[i][j][2] = -U[i][4 - j][2];
      U[i][j][3] = U[i][4 - j][3];
    }

  //非计算区域置零
  for (i = Nx / 6 + 5; i <= Nx / 3 - 1; i++)
    for (j = 0; j <= Ny / 4 - 1; j++) {
      U[i][j][0] = 1;
      U[i][j][1] = 0;
      U[i][j][2] = 0;
      U[i][j][3] = 0.71429 / (GAMA - 1);
    }

  for (i = Nx / 2 + 5; i <= Nx * 2 / 3 - 1; i++)
    for (j = Ny * 3 / 4 + 5; j <= Ny + 4; j++) {
      U[i][j][0] = 1;
      U[i][j][1] = 0;
      U[i][j][2] = 0;
      U[i][j][3] = 0.71429 / (GAMA - 1);
    }

  //凸角点处理共四个
  //上边界第二三段交界角点
  U[Nx / 2 + 3][Ny * 3 / 4 + 4][0] = U[Nx / 2 + 1][Ny * 3 / 4 + 4][0];
  U[Nx / 2 + 3][Ny * 3 / 4 + 4][1] = -U[Nx / 2 + 1][Ny * 3 / 4 + 4][1];
  U[Nx / 2 + 3][Ny * 3 / 4 + 4][2] = -U[Nx / 2 + 1][Ny * 3 / 4 + 4][2];
  U[Nx / 2 + 3][Ny * 3 / 4 + 4][3] = U[Nx / 2 + 1][Ny * 3 / 4 + 4][3];

  U[Nx / 2 + 4][Ny * 3 / 4 + 3][0] = U[Nx / 2 + 4][Ny * 3 / 4 + 1][0];
  U[Nx / 2 + 4][Ny * 3 / 4 + 3][1] = -U[Nx / 2 + 4][Ny * 3 / 4 + 1][1];
  U[Nx / 2 + 4][Ny * 3 / 4 + 3][2] = -U[Nx / 2 + 4][Ny * 3 / 4 + 1][2];
  U[Nx / 2 + 4][Ny * 3 / 4 + 3][3] = U[Nx / 2 + 4][Ny * 3 / 4 + 1][3];

  U[Nx / 2 + 3][Ny * 3 / 4 + 3][0] = 0.5 * (U[Nx / 2 + 3][Ny * 3 / 4 + 1][0] + U[Nx / 2 + 1][Ny * 3 / 4 + 3][0]);
  U[Nx / 2 + 3][Ny * 3 / 4 + 3][1] = 0.5 * (U[Nx / 2 + 3][Ny * 3 / 4 + 1][1] + U[Nx / 2 + 1][Ny * 3 / 4 + 3][1]);
  U[Nx / 2 + 3][Ny * 3 / 4 + 3][2] = 0.5 * (U[Nx / 2 + 3][Ny * 3 / 4 + 1][2] + U[Nx / 2 + 1][Ny * 3 / 4 + 3][2]);
  U[Nx / 2 + 3][Ny * 3 / 4 + 3][3] = 0.5 * (U[Nx / 2 + 3][Ny * 3 / 4 + 1][3] + U[Nx / 2 + 1][Ny * 3 / 4 + 3][3]);

  U[Nx / 2 + 2][Ny * 3 / 4 + 2][0] = 0.5 * (U[Nx / 2 + 1][Ny * 3 / 4 + 2][0] + U[Nx / 2 + 2][Ny * 3 / 4 + 1][0]);
  U[Nx / 2 + 2][Ny * 3 / 4 + 2][1] = U[Nx / 2 + 2][Ny * 3 / 4 + 1][1];
  U[Nx / 2 + 2][Ny * 3 / 4 + 2][2] = U[Nx / 2 + 1][Ny * 3 / 4 + 2][2];
  U[Nx / 2 + 2][Ny * 3 / 4 + 2][3] = 0.5 * (U[Nx / 2 + 1][Ny * 3 / 4 + 2][3] + U[Nx / 2 + 2][Ny * 3 / 4 + 1][3]);

  U[Nx / 2 + 4][Ny * 3 / 4 + 4][0] = U[Nx / 2 + 2][Ny * 3 / 4 + 2][0];
  U[Nx / 2 + 4][Ny * 3 / 4 + 4][1] = -U[Nx / 2 + 2][Ny * 3 / 4 + 2][1];
  U[Nx / 2 + 4][Ny * 3 / 4 + 4][2] = -U[Nx / 2 + 2][Ny * 3 / 4 + 2][2];
  U[Nx / 2 + 4][Ny * 3 / 4 + 4][3] = U[Nx / 2 + 2][Ny * 3 / 4 + 2][3];

  //上边界第三四段交界角点
  U[Nx * 2 / 3][Ny * 3 / 4 + 3][0] = U[Nx * 2 / 3][Ny * 3 / 4 + 1][0];
  U[Nx * 2 / 3][Ny * 3 / 4 + 3][1] = -U[Nx * 2 / 3][Ny * 3 / 4 + 1][1];
  U[Nx * 2 / 3][Ny * 3 / 4 + 3][2] = -U[Nx * 2 / 3][Ny * 3 / 4 + 1][2];
  U[Nx * 2 / 3][Ny * 3 / 4 + 3][3] = U[Nx * 2 / 3][Ny * 3 / 4 + 1][3];

  U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 4][0] = U[Nx * 2 / 3 + 3][Ny * 3 / 4 + 4][0];
  U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 4][1] = -U[Nx * 2 / 3 + 3][Ny * 3 / 4 + 4][1];
  U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 4][2] = -U[Nx * 2 / 3 + 3][Ny * 3 / 4 + 4][2];
  U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 4][3] = U[Nx * 2 / 3 + 3][Ny * 3 / 4 + 4][3];

  U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 3][0] =
      0.5 * (U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 1][0] + U[Nx * 2 / 3 + 3][Ny * 3 / 4 + 3][0]);
  U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 3][1] =
      0.5 * (U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 1][1] + U[Nx * 2 / 3 + 3][Ny * 3 / 4 + 3][1]);
  U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 3][2] =
      0.5 * (U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 1][2] + U[Nx * 2 / 3 + 3][Ny * 3 / 4 + 3][2]);
  U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 3][3] =
      0.5 * (U[Nx * 2 / 3 + 1][Ny * 3 / 4 + 1][3] + U[Nx * 2 / 3 + 3][Ny * 3 / 4 + 3][3]);

  U[Nx * 2 / 3 + 2][Ny * 3 / 4 + 2][0] =
      0.5 * (U[Nx * 2 / 3 + 2][Ny * 3 / 4 + 1][0] + U[Nx * 2 / 3 + 3][Ny * 3 / 4 + 2][0]);
  U[Nx * 2 / 3 + 2][Ny * 3 / 4 + 2][1] = U[Nx * 2 / 3 + 2][Ny * 3 / 4 + 1][1];
  U[Nx * 2 / 3 + 2][Ny * 3 / 4 + 2][2] = U[Nx * 2 / 3 + 3][Ny * 3 / 4 + 2][2];
  U[Nx * 2 / 3 + 2][Ny * 3 / 4 + 2][3] =
      0.5 * (U[Nx * 2 / 3 + 2][Ny * 3 / 4 + 1][3] + U[Nx * 2 / 3 + 3][Ny * 3 / 4 + 2][3]);

  U[Nx * 2 / 3][Ny * 3 / 4 + 4][0] = U[Nx * 2 / 3 + 2][Ny * 3 / 4 + 2][0];
  U[Nx * 2 / 3][Ny * 3 / 4 + 4][1] = -U[Nx * 2 / 3 + 2][Ny * 3 / 4 + 2][1];
  U[Nx * 2 / 3][Ny * 3 / 4 + 4][2] = -U[Nx * 2 / 3 + 2][Ny * 3 / 4 + 2][2];
  U[Nx * 2 / 3][Ny * 3 / 4 + 4][3] = U[Nx * 2 / 3 + 2][Ny * 3 / 4 + 2][3];

  //下边界第二三段交界角点
  U[Nx / 6 + 3][Ny / 4][0] = U[Nx / 6 + 1][Ny / 4][0];
  U[Nx / 6 + 3][Ny / 4][1] = -U[Nx / 6 + 1][Ny / 4][1];
  U[Nx / 6 + 3][Ny / 4][2] = -U[Nx / 6 + 1][Ny / 4][2];
  U[Nx / 6 + 3][Ny / 4][3] = U[Nx / 6 + 1][Ny / 4][3];

  U[Nx / 6 + 4][Ny / 4 + 1][0] = U[Nx / 6 + 4][Ny / 4 + 3][0];
  U[Nx / 6 + 4][Ny / 4 + 1][1] = -U[Nx / 6 + 4][Ny / 4 + 3][1];
  U[Nx / 6 + 4][Ny / 4 + 1][2] = -U[Nx / 6 + 4][Ny / 4 + 3][2];
  U[Nx / 6 + 4][Ny / 4 + 1][3] = U[Nx / 6 + 4][Ny / 4 + 3][3];

  U[Nx / 6 + 3][Ny / 4 + 1][0] = 0.5 * (U[Nx / 6 + 1][Ny / 4 + 1][0] + U[Nx / 6 + 3][Ny / 4 + 3][0]);
  U[Nx / 6 + 3][Ny / 4 + 1][1] = 0.5 * (U[Nx / 6 + 1][Ny / 4 + 1][1] + U[Nx / 6 + 3][Ny / 4 + 3][1]);
  U[Nx / 6 + 3][Ny / 4 + 1][2] = 0.5 * (U[Nx / 6 + 1][Ny / 4 + 1][2] + U[Nx / 6 + 3][Ny / 4 + 3][2]);
  U[Nx / 6 + 3][Ny / 4 + 1][3] = 0.5 * (U[Nx / 6 + 1][Ny / 4 + 1][3] + U[Nx / 6 + 3][Ny / 4 + 3][3]);

  U[Nx / 6 + 2][Ny / 4 + 2][0] = 0.5 * (U[Nx / 6 + 1][Ny / 4 + 2][0] + U[Nx / 6 + 2][Ny / 4 + 3][0]);
  U[Nx / 6 + 2][Ny / 4 + 2][1] = U[Nx / 6 + 2][Ny / 4 + 3][1];
  U[Nx / 6 + 2][Ny / 4 + 2][2] = U[Nx / 6 + 1][Ny / 4 + 2][2];
  U[Nx / 6 + 2][Ny / 4 + 2][3] = 0.5 * (U[Nx / 6 + 1][Ny / 4 + 2][3] + U[Nx / 6 + 2][Ny / 4 + 3][3]);

  U[Nx / 6 + 4][Ny / 4][0] = U[Nx / 6 + 2][Ny / 4 + 2][0];
  U[Nx / 6 + 4][Ny / 4][1] = -U[Nx / 6 + 2][Ny / 4 + 2][1];
  U[Nx / 6 + 4][Ny / 4][2] = -U[Nx / 6 + 2][Ny / 4 + 2][2];
  U[Nx / 6 + 4][Ny / 4][3] = U[Nx / 6 + 2][Ny / 4 + 2][3];
  //下边界第三四段交界角点
  U[Nx / 3][Ny / 4 + 1][0] = U[Nx / 3][Ny / 4 + 3][0];
  U[Nx / 3][Ny / 4 + 1][1] = -U[Nx / 3][Ny / 4 + 3][1];
  U[Nx / 3][Ny / 4 + 1][2] = -U[Nx / 3][Ny / 4 + 3][2];
  U[Nx / 3][Ny / 4 + 1][3] = U[Nx / 3][Ny / 4 + 3][3];

  U[Nx / 3 + 1][Ny / 4][0] = U[Nx / 3 + 3][Ny / 4][0];
  U[Nx / 3 + 1][Ny / 4][1] = -U[Nx / 3 + 3][Ny / 4][1];
  U[Nx / 3 + 1][Ny / 4][2] = -U[Nx / 3 + 3][Ny / 4][2];
  U[Nx / 3 + 1][Ny / 4][3] = U[Nx / 3 + 3][Ny / 4][3];

  U[Nx / 3 + 1][Ny / 4 + 1][0] = 0.5 * (U[Nx / 3 + 3][Ny / 4 + 1][0] + U[Nx / 3 + 1][Ny / 4 + 3][0]);
  U[Nx / 3 + 1][Ny / 4 + 1][1] = 0.5 * (U[Nx / 3 + 3][Ny / 4 + 1][1] + U[Nx / 3 + 1][Ny / 4 + 3][1]);
  U[Nx / 3 + 1][Ny / 4 + 1][2] = 0.5 * (U[Nx / 3 + 3][Ny / 4 + 1][2] + U[Nx / 3 + 1][Ny / 4 + 3][2]);
  U[Nx / 3 + 1][Ny / 4 + 1][3] = 0.5 * (U[Nx / 3 + 3][Ny / 4 + 1][3] + U[Nx / 3 + 1][Ny / 4 + 3][3]);

  U[Nx / 3 + 2][Ny / 4 + 2][0] = 0.5 * (U[Nx / 3 + 3][Ny / 4 + 2][0] + U[Nx / 3 + 2][Ny / 4 + 3][0]);
  U[Nx / 3 + 2][Ny / 4 + 2][1] = U[Nx / 3 + 2][Ny / 4 + 3][1];
  U[Nx / 3 + 2][Ny / 4 + 2][2] = U[Nx / 3 + 3][Ny / 4 + 2][2];
  U[Nx / 3 + 2][Ny / 4 + 2][3] = 0.5 * (U[Nx / 3 + 3][Ny / 4 + 2][3] + U[Nx / 3 + 2][Ny / 4 + 3][3]);

  U[Nx / 3][Ny / 4][0] = U[Nx / 3 + 2][Ny / 4 + 2][0];
  U[Nx / 3][Ny / 4][1] = -U[Nx / 3 + 2][Ny / 4 + 2][1];
  U[Nx / 3][Ny / 4][2] = -U[Nx / 3 + 2][Ny / 4 + 2][2];
  U[Nx / 3][Ny / 4][3] = U[Nx / 3 + 2][Ny / 4 + 2][3];
}

// Supersonic
void bound_3(double U[Nx+7][Ny+7][4],double dx,double dy)
{
	int i,j,k;
	double rou1=1.4,u1=3.0,v1=0,p1=1.0;

  int N_x=(int)(XPOS/dx)+2;
	int N_y=(int)(YPOS/dy)+2;

//左边界	
	for(j=0;j<=Ny+4;j++)
	{
		U[0][j][0]=rou1;
		U[0][j][1]=rou1*u1;
		U[0][j][2]=rou1*v1;
		U[0][j][3]=p1/(GAMA-1)+0.5*rou1*(u1*u1+v1*v1);

		U[1][j][0]=rou1;
		U[1][j][1]=rou1*u1;
		U[1][j][2]=rou1*v1;
		U[1][j][3]=p1/(GAMA-1)+0.5*rou1*(u1*u1+v1*v1);
	}

//上边界
	for(i=0;i<=Nx+4;i++)
	{
		U[i][Ny+3][0]=U[i][Ny+1][0];
		U[i][Ny+3][1]=U[i][Ny+1][1];
		U[i][Ny+3][2]=-U[i][Ny+1][2];
		U[i][Ny+3][3]=U[i][Ny+1][3];

		U[i][Ny+4][0]=U[i][Ny][0];
		U[i][Ny+4][1]=U[i][Ny][1];
		U[i][Ny+4][2]=-U[i][Ny][2];
		U[i][Ny+4][3]=U[i][Ny][3];
	}

//右边界
	for(j=N_y;j<=Ny+4;j++)
		for(k=0;k<4;k++)
		{
			U[Nx+3][j][k]=U[Nx+2][j][k];
			U[Nx+4][j][k]=U[Nx+3][j][k];                                                                                     
		}	

//左下边界
	for(i=0;i<=N_x;i++)
	{
		U[i][0][0]=U[i][4][0];
		U[i][0][1]=U[i][4][1];
		U[i][0][2]=-U[i][4][2];
		U[i][0][3]=U[i][4][3];

		U[i][1][0]=U[i][3][0];
		U[i][1][1]=U[i][3][1];
		U[i][1][2]=-U[i][3][2];
		U[i][1][3]=U[i][3][3];

	
	}

//右下边界
	for(i=N_x+3;i<=Nx+2;i++)
	{
		U[i][N_y-2][0]=U[i][N_y+2][0];
		U[i][N_y-2][1]=U[i][N_y+2][1];
		U[i][N_y-2][2]=-U[i][N_y+2][2];
		U[i][N_y-2][3]=U[i][N_y+2][3];

		U[i][N_y-1][0]=U[i][N_y+1][0];
		U[i][N_y-1][1]=U[i][N_y+1][1];
		U[i][N_y-1][2]=-U[i][N_y+1][2];
		U[i][N_y-1][3]=U[i][N_y+1][3];
	}

  //台阶y方向的边界处理
	for(j=2;j<N_y-2;j++)
	{		
		U[N_x+2][j][0]=U[N_x-2][j][0];
		U[N_x+2][j][1]=-U[N_x-2][j][1];
		U[N_x+2][j][2]=U[N_x-2][j][2];
		U[N_x+2][j][3]=U[N_x-2][j][3];	

		U[N_x+1][j][0]=U[N_x-1][j][0];
		U[N_x+1][j][1]=-U[N_x-1][j][1];
		U[N_x+1][j][2]=U[N_x-1][j][2];
		U[N_x+1][j][3]=U[N_x-1][j][3];
	}

//下角点处理
	
	for(k=0;k<=3;k++)
	{
		U[N_x+1][0][k]=U[N_x-1][4][k];
		U[N_x+1][1][k]=U[N_x-1][3][k];
		U[N_x+2][1][k]=U[N_x-2][3][k];
		U[N_x+2][0][k]=U[N_x-2][4][k];	
	}
	
//上角点处理
		U[N_x+2][N_y-1][0]=U[N_x+2][N_y+1][0];
		U[N_x+2][N_y-1][1]=U[N_x+2][N_y+1][1];
		U[N_x+2][N_y-1][2]=-U[N_x+2][N_y+1][2];
		U[N_x+2][N_y-1][3]=U[N_x+2][N_y+1][3];

		U[N_x+1][N_y-2][0]=U[N_x-1][N_y-2][0];
		U[N_x+1][N_y-2][1]=-U[N_x-1][N_y-2][1];
		U[N_x+1][N_y-2][2]=U[N_x-1][N_y-2][2];
		U[N_x+1][N_y-2][3]=U[N_x-1][N_y-2][3];

		U[N_x+2][N_y-2][0]=U[N_x][N_y][0];
		U[N_x+2][N_y-2][1]=-U[N_x][N_y][1];
		U[N_x+2][N_y-2][2]=-U[N_x][N_y][2];
		U[N_x+2][N_y-2][3]=U[N_x][N_y][3];

		U[N_x+1][N_y-1][0]=0.5*(U[N_x-1][N_y-1][0]+U[N_x+1][N_y+1][0]);
		U[N_x+1][N_y-1][1]=0.5*(U[N_x-1][N_y-1][1]+U[N_x+1][N_y+1][1]);
		U[N_x+1][N_y-1][2]=0.5*(U[N_x-1][N_y-1][2]+U[N_x+1][N_y+1][2]);
		U[N_x+1][N_y-1][3]=0.5*(U[N_x-1][N_y-1][3]+U[N_x+1][N_y+1][3]);

		j=Ny+2;
		for(i=2;i<=Nx+2;i++)
	{
		U[i][j][2]=0;
	}//上边界壁面法向速度强制赋0

		j=2;
		for(i=2;i<=N_x;i++)
	{
		U[i][j][2]=0;
	}//下边界壁面法向速度强制赋0
		
		j=N_y;
		for(i=N_x;i<=Nx+2;i++)
	{
		U[i][j][2]=0;
	}//下边界壁面法向速度强制赋0

		i=N_x;
		for(j=2;j<=N_y;j++)
	{
		U[i][j][1]=0;
	}//台阶垂直壁面法向速度强制赋0

}

// simplest case
/*------------------------------------------------------
边界条件
入口：dx，dy，网格宽度
出口：U，已经给定边界
--------------------------------------------------------*/
void bound_4(double U[Nx+7][Ny+7][4]) {
	int i,j;
	for(j=0;j<=Nx;j++)
		for(i=0;i<=3;i++)
			U[0][j][i]=U[1][j][i];//下边界
	for(j=0;j<=Nx;j++)
		for(i=0;i<=3;i++)
			U[Ny][j][i]=U[Ny-1][j][i];//上边界
	for(j=0;j<=Nx;j++)
		for(i=0;i<=3;i++)
			U[j][0][i]=U[j][1][i];//左边界
	for(j=0;j<=Nx;j++)
		for(i=0;i<=3;i++)
			U[j][Nx][i]=U[j][Nx-1][i];//右边界
}

//MUSCL
void bound_5(double U[Nx+7][Ny+7][4])
{
	int i,j,a,b,s;
	double rou1=1,u1=0,v1=0,a1=1,p1=0.71429;
	double rou2=3.85714,p2=7.381,u2=2.22223,v2=0;
	double dx,dy;
	dx=Lx/Nx;
	dy=Ly/Ny;

	for(i=0;i<=2;i++)//左边界入口条件
	{
		for(j=0;j<=Ny+4;j++)
		{
			U[i][j][0]=rou2;
			U[i][j][1]=rou2*u2;
			U[i][j][2]=rou2*v2;
			U[i][j][3]=p2/(GAMA-1)+0.5*rou2*(u2*u2+v2*v2);
		}
	}
	for(i=Nx+3;i<=Nx+4;i++)//右边界出口条件
	{
		for(j=0;j<=Ny+4;j++)
		{
			U[i][j][0]=U[i-1][j][0];
			U[i][j][1]=U[i-1][j][1];
			U[i][j][2]=U[i-1][j][2];
			U[i][j][3]=U[i-1][j][3];
		}
	}
//虚拟节点的处理,这里采用镜面反射,标量和切向速度取相同值,法相速度取相反值
	
	for(i=3;i<=Nx+2;i++)//上下壁面
	{
	for(j=0;j<=1;j++)
		{
			U[i][j][0]=U[i][-j+4][0];
			U[i][j][1]=U[i][-j+4][1];
			U[i][j][2]=-U[i][-j+4][2];
			U[i][j][3]=U[i][-j+4][3];
		}
	for(j=Ny+3;j<=Ny+4;j++)
		{
			U[i][j][0]=U[i][-j+2*Ny+4][0];
			U[i][j][1]=U[i][-j+2*Ny+4][1];
			U[i][j][2]=-U[i][-j+2*Ny+4][2];
			U[i][j][3]=U[i][-j+2*Ny+4][3];
		}
	}

	for(i=2;i<=Nx+2;i++)//上下壁面边界法向强行赋值为零
		{
		U[i][2][2]=0;
		U[i][Ny+2][2]=0;
		}

	//左方柱

	for(j=int(0.8/dy)+5;j<=int(1.2/dy)-1;j++)//左方柱左右表面虚拟点
	{
		for(i=int(1.0/dx)+3;i<=int(1.0/dx)+4;i++)
		{
			U[i][j][0]=U[2*int(1.0/dx)+4-i][j][0];
			U[i][j][1]=-U[2*int(1.0/dx)+4-i][j][1];
			U[i][j][2]=U[2*int(1.0/dx)+4-i][j][2];
			U[i][j][3]=U[2*int(1.0/dx)+4-i][j][3];
		}
		for(i=int(1.2/dx);i<=int(1.2/dx)+1;i++)
			{		
			U[i][j][0]=U[2*int(1.2/dx)+4-i][j][0];
			U[i][j][1]=-U[2*int(1.2/dx)+4-i][j][1];
			U[i][j][2]=U[2*int(1.2/dx)+4-i][j][2];
			U[i][j][3]=U[2*int(1.2/dx)+4-i][j][3];	
			}
	}	
	for(i=int(1.0/dx)+5;i<=int(1.2/dx)-1;i++)//左方柱上下表面虚拟点
	{
		for(j=int(1.2/dy);j<=int(1.2/dy)+1;j++)
		{
			U[i][j][0]=U[i][-j+2*int(1.2/dy)+4][0];
			U[i][j][1]=U[i][-j+2*int(1.2/dy)+4][1];
			U[i][j][2]=-U[i][-j+2*int(1.2/dy)+4][2];
			U[i][j][3]=U[i][-j+2*int(1.2/dy)+4][3];
		}
		for(j=int(0.8/dy)+3;j<=int(0.8/dy)+4;j++)
		{
			U[i][j][0]=U[i][-j+2*int(0.8/dy)+4][0];
			U[i][j][1]=U[i][-j+2*int(0.8/dy)+4][1];
			U[i][j][2]=-U[i][-j+2*int(0.8/dy)+4][2];
			U[i][j][3]=U[i][-j+2*int(0.8/dy)+4][3];
		}
	}
	//左方柱 角点的虚拟网格处理
	{
	a=int(1.2/dx)+2;    //方柱右下角角凸点(a,b)
	b=int(0.8/dy)+2;

		U[a][b][0]=0.5*(U[a][b-1][0]+U[a+1][b][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a][b-1][3]+U[a+1][b][3]);

		U[a-1][b+2][0]=U[a+1][b+2][0];
		U[a-1][b+2][1]=-U[a+1][b+2][1];
		U[a-1][b+2][2]=U[a+1][b+2][2];
		U[a-1][b+2][3]=U[a+1][b+2][3];

		U[a-2][b+1][0]=U[a-2][b-1][0];
		U[a-2][b+1][1]=U[a-2][b-1][1];
		U[a-2][b+1][2]=-U[a-2][b-1][2];
		U[a-2][b+1][3]=U[a-2][b-1][3];

		U[a-1][b+1][0]=0.5*(U[a-1][b-1][0]+U[a+1][b+1][0]);
		U[a-1][b+1][1]=0.5*(U[a-1][b-1][1]+U[a+1][b+1][1]);
		U[a-1][b+1][2]=0.5*(U[a-1][b-1][2]+U[a+1][b+1][2]);
		U[a-1][b+1][3]=0.5*(U[a-1][b-1][3]+U[a+1][b+1][3]);

		U[a-2][b+2][0]=U[a][b][0];
		U[a-2][b+2][1]=-U[a][b][1];
		U[a-2][b+2][2]=-U[a][b][2];
		U[a-2][b+2][3]=U[a][b][3];
	
	a=int(1.0/dx)+2;//方柱左下角
	b=int(0.8/dy)+2;

		U[a][b][0]=0.5*(U[a-1][b][0]+U[a][b-1][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a-1][b][3]+U[a][b-1][3]);
	
		U[a+1][b+2][0]=U[a-1][b+2][0];
		U[a+1][b+2][1]=-U[a-1][b+2][1];
		U[a+1][b+2][2]=U[a-1][b+2][2];
		U[a+1][b+2][3]=U[a-1][b+2][3];

		U[a+2][b+1][0]=U[a+2][b-1][0];
		U[a+2][b+1][1]=U[a+2][b-1][1];
		U[a+2][b+1][2]=-U[a+2][b-1][2];
		U[a+2][b+1][3]=U[a+2][b-1][3];

		U[a+1][b+1][0]=0.5*(U[a-1][b+1][0]+U[a+1][b-1][0]);
		U[a+1][b+1][1]=0.5*(U[a-1][b+1][1]+U[a+1][b-1][1]);
		U[a+1][b+1][2]=0.5*(U[a-1][b+1][2]+U[a+1][b-1][2]);
		U[a+1][b+1][3]=0.5*(U[a-1][b+1][3]+U[a+1][b-1][3]);

		U[a+2][b+2][0]=U[a][b][0];
		U[a+2][b+2][1]=-U[a][b][1];
		U[a+2][b+2][2]=-U[a][b][2];
		U[a+2][b+2][3]=U[a][b][3];
	
	a=int(1.0/dx)+2;//方柱左上角
	b=int(1.2/dy)+2;

		U[a][b][0]=0.5*(U[a][b+1][0]+U[a-1][b][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a][b+1][3]+U[a-1][b][3]);
		
		U[a+1][b-2][0]=U[a-1][b-2][0];
		U[a+1][b-2][1]=-U[a-1][b-2][1];
		U[a+1][b-2][2]=U[a-1][b-2][2];
		U[a+1][b-2][3]=U[a-1][b-2][3];

		U[a+2][b-1][0]=U[a+2][b+1][0];
		U[a+2][b-1][1]=U[a+2][b+1][1];
		U[a+2][b-1][2]=-U[a+2][b+1][2];
		U[a+2][b-1][3]=U[a+2][b+1][3];

		U[a+1][b-1][0]=0.5*(U[a-1][b-1][0]+U[a+1][b+1][0]);
		U[a+1][b-1][1]=0.5*(U[a-1][b-1][1]+U[a+1][b+1][1]);
		U[a+1][b-1][2]=0.5*(U[a-1][b-1][2]+U[a+1][b+1][2]);
		U[a+1][b-1][3]=0.5*(U[a-1][b-1][3]+U[a+1][b+1][3]);

		U[a+2][b-2][0]=U[a][b][0];
		U[a+2][b-2][1]=-U[a][b][1];
		U[a+2][b-2][2]=-U[a][b][2];
		U[a+2][b-2][3]=U[a][b][3];

	a=int(1.2/dx)+2;//方柱右上角
	b=int(1.2/dy)+2;

		U[a][b][0]=0.5*(U[a][b+1][0]+U[a+1][b][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a][b+1][3]+U[a+1][b][3]);
	
		U[a-1][b-2][0]=U[a+1][b-2][0];
		U[a-1][b-2][1]=-U[a+1][b-2][1];
		U[a-1][b-2][2]=U[a+1][b-2][2];
		U[a-1][b-2][3]=U[a+1][b-2][3];

		U[a-2][b-1][0]=U[a-2][b+1][0];
		U[a-2][b-1][1]=U[a-2][b+1][1];
		U[a-2][b-1][2]=-U[a-2][b+1][2];
		U[a-2][b-1][3]=U[a-2][b+1][3];

		U[a-1][b-1][0]=0.5*(U[a-1][b+1][0]+U[a+1][b-1][0]);
		U[a-1][b-1][1]=0.5*(U[a-1][b+1][1]+U[a+1][b-1][1]);
		U[a-1][b-1][2]=0.5*(U[a-1][b+1][2]+U[a+1][b-1][2]);
		U[a-1][b-1][3]=0.5*(U[a-1][b+1][3]+U[a+1][b-1][3]);

		U[a-2][b-2][0]=U[a][b][0];
		U[a-2][b-2][1]=-U[a][b][1];
		U[a-2][b-2][2]=-U[a][b][2];
		U[a-2][b-2][3]=U[a][b][3];
	}

	//边界上强行赋法向为零

	
	for(i=int(1.0/dx)+2;i<=int(1.2/dx)+2;i++)//左方柱上下壁面边界
		{
		U[i][int(1.2/dy)+2][2]=0;
		U[i][int(0.8/dy)+2][2]=0;
		}
	for(j=int(0.8/dy)+2;j<=int(1.2/dy)+2;j++)//左方柱左右边界
		{
		U[int(1.0/dx)+2][j][1]=0;
		U[int(1.2/dx)+2][j][1]=0;
		}
	//左方柱内部赋值为零

	for(i=int(1.0/dx)+5;i<=int(1.2/dy)-1;i++)
			for(j=int(0.8/dy)+5;j<=int(1.2/dy)-1;j++)
						for(s=0;s<=3;s++)
						U[i][j][s]=0;


//右方柱
	for(j=int(0.8/dy)+5;j<=int(1.2/dy)-1;j++) //右方柱左右表面虚拟点
	{
		for(i=int(2.0/dx)+3;i<=int(2.0/dx)+4;i++)
		{
			U[i][j][0]=U[2*int(2.0/dx)+4-i][j][0];
			U[i][j][1]=-U[2*int(2.0/dx)+4-i][j][1];
			U[i][j][2]=U[2*int(2.0/dx)+4-i][j][2];
			U[i][j][3]=U[2*int(2.0/dx)+4-i][j][3];
		}
		for(i=int(2.2/dx);i<=int(2.2/dx)+1;i++)
			{		
			U[i][j][0]=U[2*int(2.2/dx)+4-i][j][0];
			U[i][j][1]=-U[2*int(2.2/dx)+4-i][j][1];
			U[i][j][2]=U[2*int(2.2/dx)+4-i][j][2];
			U[i][j][3]=U[2*int(2.2/dx)+4-i][j][3];	
			}
	}	
	for(i=int(2.0/dx)+5;i<=int(2.2/dx)-1;i++) //方柱上下表面虚拟点
	{
		for(j=int(1.2/dy);j<=int(1.2/dy)+1;j++)
		{
			U[i][j][0]=U[i][-j+2*int(1.2/dy)+4][0];
			U[i][j][1]=U[i][-j+2*int(1.2/dy)+4][1];
			U[i][j][2]=-U[i][-j+2*int(1.2/dy)+4][2];
			U[i][j][3]=U[i][-j+2*int(1.2/dy)+4][3];
		}
		for(j=int(0.8/dy)+3;j<=int(0.8/dy)+4;j++)
		{
			U[i][j][0]=U[i][-j+2*int(0.8/dy)+4][0];
			U[i][j][1]=U[i][-j+2*int(0.8/dy)+4][1];
			U[i][j][2]=-U[i][-j+2*int(0.8/dy)+4][2];
			U[i][j][3]=U[i][-j+2*int(0.8/dy)+4][3];
		}
	}
	//右角点的虚拟网格处理
	{
	a=int(2.2/dx)+2;    //方柱右下角角凸点(a,b)以及其附近虚拟节点处理
	b=int(0.8/dy)+2;

		U[a][b][0]=0.5*(U[a][b-1][0]+U[a+1][b][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a][b-1][3]+U[a+1][b][3]);

		U[a-1][b+2][0]=U[a+1][b+2][0];
		U[a-1][b+2][1]=-U[a+1][b+2][1];
		U[a-1][b+2][2]=U[a+1][b+2][2];
		U[a-1][b+2][3]=U[a+1][b+2][3];

		U[a-2][b+1][0]=U[a-2][b-1][0];
		U[a-2][b+1][1]=U[a-2][b-1][1];
		U[a-2][b+1][2]=-U[a-2][b-1][2];
		U[a-2][b+1][3]=U[a-2][b-1][3];

		U[a-1][b+1][0]=0.5*(U[a-1][b-1][0]+U[a+1][b+1][0]);
		U[a-1][b+1][1]=0.5*(U[a-1][b-1][1]+U[a+1][b+1][1]);
		U[a-1][b+1][2]=0.5*(U[a-1][b-1][2]+U[a+1][b+1][2]);
		U[a-1][b+1][3]=0.5*(U[a-1][b-1][3]+U[a+1][b+1][3]);

		U[a-2][b+2][0]=U[a][b][0];
		U[a-2][b+2][1]=-U[a][b][1];
		U[a-2][b+2][2]=-U[a][b][2];
		U[a-2][b+2][3]=U[a][b][3];
	
	a=int(2.0/dx)+2; //方柱左下角
	b=int(0.8/dy)+2;

		U[a][b][0]=0.5*(U[a-1][b][0]+U[a][b-1][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a-1][b][3]+U[a][b-1][3]);
	
		U[a+1][b+2][0]=U[a-1][b+2][0];
		U[a+1][b+2][1]=-U[a-1][b+2][1];
		U[a+1][b+2][2]=U[a-1][b+2][2];
		U[a+1][b+2][3]=U[a-1][b+2][3];

		U[a+2][b+1][0]=U[a+2][b-1][0];
		U[a+2][b+1][1]=U[a+2][b-1][1];
		U[a+2][b+1][2]=-U[a+2][b-1][2];
		U[a+2][b+1][3]=U[a+2][b-1][3];

		U[a+1][b+1][0]=0.5*(U[a-1][b+1][0]+U[a+1][b-1][0]);
		U[a+1][b+1][1]=0.5*(U[a-1][b+1][1]+U[a+1][b-1][1]);
		U[a+1][b+1][2]=0.5*(U[a-1][b+1][2]+U[a+1][b-1][2]);
		U[a+1][b+1][3]=0.5*(U[a-1][b+1][3]+U[a+1][b-1][3]);

		U[a+2][b+2][0]=U[a][b][0];
		U[a+2][b+2][1]=-U[a][b][1];
		U[a+2][b+2][2]=-U[a][b][2];
		U[a+2][b+2][3]=U[a][b][3];
	
	a=int(2.0/dx)+2;//方柱左上角
	b=int(1.2/dy)+2;

		U[a][b][0]=0.5*(U[a][b+1][0]+U[a-1][b][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a][b+1][3]+U[a-1][b][3]);
		
		U[a+1][b-2][0]=U[a-1][b-2][0];
		U[a+1][b-2][1]=-U[a-1][b-2][1];
		U[a+1][b-2][2]=U[a-1][b-2][2];
		U[a+1][b-2][3]=U[a-1][b-2][3];

		U[a+2][b-1][0]=U[a+2][b+1][0];
		U[a+2][b-1][1]=U[a+2][b+1][1];
		U[a+2][b-1][2]=-U[a+2][b+1][2];
		U[a+2][b-1][3]=U[a+2][b+1][3];

		U[a+1][b-1][0]=0.5*(U[a-1][b-1][0]+U[a+1][b+1][0]);
		U[a+1][b-1][1]=0.5*(U[a-1][b-1][1]+U[a+1][b+1][1]);
		U[a+1][b-1][2]=0.5*(U[a-1][b-1][2]+U[a+1][b+1][2]);
		U[a+1][b-1][3]=0.5*(U[a-1][b-1][3]+U[a+1][b+1][3]);

		U[a+2][b-2][0]=U[a][b][0];
		U[a+2][b-2][1]=-U[a][b][1];
		U[a+2][b-2][2]=-U[a][b][2];
		U[a+2][b-2][3]=U[a][b][3];

	a=int(2.2/dx)+2;//方柱右上角
	b=int(1.2/dy)+2;

		U[a][b][0]=0.5*(U[a][b+1][0]+U[a+1][b][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a][b+1][3]+U[a+1][b][3]);
	
		U[a-1][b-2][0]=U[a+1][b-2][0];
		U[a-1][b-2][1]=-U[a+1][b-2][1];
		U[a-1][b-2][2]=U[a+1][b-2][2];
		U[a-1][b-2][3]=U[a+1][b-2][3];

		U[a-2][b-1][0]=U[a-2][b+1][0];
		U[a-2][b-1][1]=U[a-2][b+1][1];
		U[a-2][b-1][2]=-U[a-2][b+1][2];
		U[a-2][b-1][3]=U[a-2][b+1][3];

		U[a-1][b-1][0]=0.5*(U[a-1][b+1][0]+U[a+1][b-1][0]);
		U[a-1][b-1][1]=0.5*(U[a-1][b+1][1]+U[a+1][b-1][1]);
		U[a-1][b-1][2]=0.5*(U[a-1][b+1][2]+U[a+1][b-1][2]);
		U[a-1][b-1][3]=0.5*(U[a-1][b+1][3]+U[a+1][b-1][3]);

		U[a-2][b-2][0]=U[a][b][0];
		U[a-2][b-2][1]=-U[a][b][1];
		U[a-2][b-2][2]=-U[a][b][2];
		U[a-2][b-2][3]=U[a][b][3];
	}
	//边界上强行赋法向为零
	
	for(i=int(2.0/dx)+2;i<=int(2.2/dx)+2;i++)//方柱上下壁面边界
		{
		U[i][int(1.2/dy)+2][2]=0;
		U[i][int(0.8/dy)+2][2]=0;
		}
	for(j=int(0.8/dy)+2;j<=int(1.2/dy)+2;j++)//方柱左右边界
		{
		U[int(2.0/dx)+2][j][1]=0;
		U[int(2.2/dx)+2][j][1]=0;
		}

	//方柱内部赋值为零
	for(i=int(2.0/dx)+5;i<=int(2.2/dy)-1;i++)
			for(j=int(0.8/dy)+5;j<=int(1.2/dy)-1;j++)
						for(s=0;s<=3;s++)
						U[i][j][s]=0;			
}

void bound_6(double U[Nx+7][Ny+7][4]){
	int i,j,a,b,s;
	double den1=1,u1=0,v1=0,a1=1,p1=0.71429;
	double den2=3.85714,p2=7.381,u2=2.22223,v2=0;
	double dx,dy;
	dx=Lx/Nx;
	dy=Ly/Ny;

	for(i=0;i<=2;i++)//左边界入口条件
	{
		for(j=0;j<=Ny+4;j++)
		{
			U[i][j][0]=den2;
			U[i][j][1]=den2*u2;
			U[i][j][2]=den2*v2;
			U[i][j][3]=p2/(GAMA-1)+0.5*den2*(u2*u2+v2*v2);
		}
	}
	for(i=Nx+3;i<=Nx+4;i++)//右边界出口条件
	{
		for(j=0;j<=Ny+4;j++)
		{
			U[i][j][0]=U[i-1][j][0];
			U[i][j][1]=U[i-1][j][1];
			U[i][j][2]=U[i-1][j][2];
			U[i][j][3]=U[i-1][j][3];
		}
	}
//虚拟节点的处理,这里采用镜面反射,标量和切向速度取相同值,法相速度取相反值
	for(i=3;i<=Nx+2;i++)//上下壁面
	{
	for(j=0;j<=1;j++)
		{
			U[i][j][0]=U[i][-j+4][0];
			U[i][j][1]=U[i][-j+4][1];
			U[i][j][2]=-U[i][-j+4][2];
			U[i][j][3]=U[i][-j+4][3];
		}
	for(j=Ny+3;j<=Ny+4;j++)
		{
			U[i][j][0]=U[i][-j+2*Ny+4][0];
			U[i][j][1]=U[i][-j+2*Ny+4][1];
			U[i][j][2]=-U[i][-j+2*Ny+4][2];
			U[i][j][3]=U[i][-j+2*Ny+4][3];
		}
	}
	for(j=int(0.6/dy)+5;j<=int(1.0/dy)-1;j++)//方柱左右表面虚拟点
	{
		for(i=int(1.0/dx)+3;i<=int(1.0/dx)+4;i++)
		{
			U[i][j][0]=U[2*int(1.0/dx)+4-i][j][0];
			U[i][j][1]=-U[2*int(1.0/dx)+4-i][j][1];
			U[i][j][2]=U[2*int(1.0/dx)+4-i][j][2];
			U[i][j][3]=U[2*int(1.0/dx)+4-i][j][3];
		}
		for(i=int(1.2/dx);i<=int(1.2/dx)+1;i++)
			{		
			U[i][j][0]=U[2*int(1.2/dx)+4-i][j][0];
			U[i][j][1]=-U[2*int(1.2/dx)+4-i][j][1];
			U[i][j][2]=U[2*int(1.2/dx)+4-i][j][2];
			U[i][j][3]=U[2*int(1.2/dx)+4-i][j][3];	
			}
	}	
	for(i=int(1.0/dx)+5;i<=int(1.2/dx)-1;i++)//方柱上下表面虚拟点
	{
		for(j=int(1.0/dy);j<=int(1.0/dy)+1;j++)
		{
			U[i][j][0]=U[i][-j+2*int(1.0/dy)+4][0];
			U[i][j][1]=U[i][-j+2*int(1.0/dy)+4][1];
			U[i][j][2]=-U[i][-j+2*int(1.0/dy)+4][2];
			U[i][j][3]=U[i][-j+2*int(1.0/dy)+4][3];
		}
		for(j=int(0.6/dy)+3;j<=int(0.6/dy)+4;j++)
		{
			U[i][j][0]=U[i][-j+2*int(0.6/dy)+4][0];
			U[i][j][1]=U[i][-j+2*int(0.6/dy)+4][1];
			U[i][j][2]=-U[i][-j+2*int(0.6/dy)+4][2];
			U[i][j][3]=U[i][-j+2*int(0.6/dy)+4][3];
		}
	}
	//角点的虚拟网格特殊处理
	{
	a=int(1.2/dx)+2;    //方柱右下角角凸点(a,b)以及其附近虚拟节点处理,处理方法参考了教材相关内容
	b=int(0.6/dy)+2;

		U[a][b][0]=0.5*(U[a][b-1][0]+U[a+1][b][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a][b-1][3]+U[a+1][b][3]);

		U[a-1][b+2][0]=U[a+1][b+2][0];
		U[a-1][b+2][1]=-U[a+1][b+2][1];
		U[a-1][b+2][2]=U[a+1][b+2][2];
		U[a-1][b+2][3]=U[a+1][b+2][3];

		U[a-2][b+1][0]=U[a-2][b-1][0];
		U[a-2][b+1][1]=U[a-2][b-1][1];
		U[a-2][b+1][2]=-U[a-2][b-1][2];
		U[a-2][b+1][3]=U[a-2][b-1][3];

		U[a-1][b+1][0]=0.5*(U[a-1][b-1][0]+U[a+1][b+1][0]);
		U[a-1][b+1][1]=0.5*(U[a-1][b-1][1]+U[a+1][b+1][1]);
		U[a-1][b+1][2]=0.5*(U[a-1][b-1][2]+U[a+1][b+1][2]);
		U[a-1][b+1][3]=0.5*(U[a-1][b-1][3]+U[a+1][b+1][3]);

		U[a-2][b+2][0]=U[a][b][0];
		U[a-2][b+2][1]=-U[a][b][1];
		U[a-2][b+2][2]=-U[a][b][2];
		U[a-2][b+2][3]=U[a][b][3];
	
	a=int(1.0/dx)+2;
	b=int(0.6/dy)+2;//方柱左下角

		U[a][b][0]=0.5*(U[a-1][b][0]+U[a][b-1][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a-1][b][3]+U[a][b-1][3]);
	
		U[a+1][b+2][0]=U[a-1][b+2][0];
		U[a+1][b+2][1]=-U[a-1][b+2][1];
		U[a+1][b+2][2]=U[a-1][b+2][2];
		U[a+1][b+2][3]=U[a-1][b+2][3];

		U[a+2][b+1][0]=U[a+2][b-1][0];
		U[a+2][b+1][1]=U[a+2][b-1][1];
		U[a+2][b+1][2]=-U[a+2][b-1][2];
		U[a+2][b+1][3]=U[a+2][b-1][3];

		U[a+1][b+1][0]=0.5*(U[a-1][b+1][0]+U[a+1][b-1][0]);
		U[a+1][b+1][1]=0.5*(U[a-1][b+1][1]+U[a+1][b-1][1]);
		U[a+1][b+1][2]=0.5*(U[a-1][b+1][2]+U[a+1][b-1][2]);
		U[a+1][b+1][3]=0.5*(U[a-1][b+1][3]+U[a+1][b-1][3]);

		U[a+2][b+2][0]=U[a][b][0];
		U[a+2][b+2][1]=-U[a][b][1];
		U[a+2][b+2][2]=-U[a][b][2];
		U[a+2][b+2][3]=U[a][b][3];
	
	a=int(1.0/dx)+2;//方柱左上角
	b=int(1.0/dy)+2;

		U[a][b][0]=0.5*(U[a][b+1][0]+U[a-1][b][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a][b+1][3]+U[a-1][b][3]);
		
		U[a+1][b-2][0]=U[a-1][b-2][0];
		U[a+1][b-2][1]=-U[a-1][b-2][1];
		U[a+1][b-2][2]=U[a-1][b-2][2];
		U[a+1][b-2][3]=U[a-1][b-2][3];

		U[a+2][b-1][0]=U[a+2][b+1][0];
		U[a+2][b-1][1]=U[a+2][b+1][1];
		U[a+2][b-1][2]=-U[a+2][b+1][2];
		U[a+2][b-1][3]=U[a+2][b+1][3];

		U[a+1][b-1][0]=0.5*(U[a-1][b-1][0]+U[a+1][b+1][0]);
		U[a+1][b-1][1]=0.5*(U[a-1][b-1][1]+U[a+1][b+1][1]);
		U[a+1][b-1][2]=0.5*(U[a-1][b-1][2]+U[a+1][b+1][2]);
		U[a+1][b-1][3]=0.5*(U[a-1][b-1][3]+U[a+1][b+1][3]);

		U[a+2][b-2][0]=U[a][b][0];
		U[a+2][b-2][1]=-U[a][b][1];
		U[a+2][b-2][2]=-U[a][b][2];
		U[a+2][b-2][3]=U[a][b][3];

	a=int(1.2/dx)+2;//方柱右上角
	b=int(1.0/dy)+2;

		U[a][b][0]=0.5*(U[a][b+1][0]+U[a+1][b][0]);
		U[a][b][1]=0;
		U[a][b][2]=0;
		U[a][b][3]=0.5*(U[a][b+1][3]+U[a+1][b][3]);
	
		U[a-1][b-2][0]=U[a+1][b-2][0];
		U[a-1][b-2][1]=-U[a+1][b-2][1];
		U[a-1][b-2][2]=U[a+1][b-2][2];
		U[a-1][b-2][3]=U[a+1][b-2][3];

		U[a-2][b-1][0]=U[a-2][b+1][0];
		U[a-2][b-1][1]=U[a-2][b+1][1];
		U[a-2][b-1][2]=-U[a-2][b+1][2];
		U[a-2][b-1][3]=U[a-2][b+1][3];

		U[a-1][b-1][0]=0.5*(U[a-1][b+1][0]+U[a+1][b-1][0]);
		U[a-1][b-1][1]=0.5*(U[a-1][b+1][1]+U[a+1][b-1][1]);
		U[a-1][b-1][2]=0.5*(U[a-1][b+1][2]+U[a+1][b-1][2]);
		U[a-1][b-1][3]=0.5*(U[a-1][b+1][3]+U[a+1][b-1][3]);

		U[a-2][b-2][0]=U[a][b][0];
		U[a-2][b-2][1]=-U[a][b][1];
		U[a-2][b-2][2]=-U[a][b][2];
		U[a-2][b-2][3]=U[a][b][3];
	}
	//边界上强行赋法向为零
	for(i=2;i<=Nx+2;i++)//上下壁面边界法向强行赋值为零
		{
		U[i][2][2]=0;
		U[i][Ny+2][2]=0;
		}
	for(i=int(1.0/dx)+2;i<=int(1.2/dx)+2;i++)//方柱上下壁面边界
		{
		U[i][int(1.0/dy)+2][2]=0;
		U[i][int(0.6/dy)+2][2]=0;
		}
	for(j=int(0.6/dy)+2;j<=int(1.0/dy)+2;j++)//方柱左右边界
		{
		U[int(1.0/dx)+2][j][1]=0;
		U[int(1.2/dx)+2][j][1]=0;
		}
	//方柱内部赋值为零
	for(i=int(1.0/dx)+5;i<=int(1.2/dy)-1;i++)
			for(j=int(0.6/dy)+5;j<=int(1.0/dy)-1;j++)
						for(s=0;s<=3;s++)
						U[i][j][s]=0;			
}

void bound(double U[Nx + 7][Ny + 7][4], double dx, double dy, int case_id) {
  if (case_id == 1) {
    bound_1(U, dx, dy);
  } else if (case_id == 2) {
    bound_2(U, dx, dy);
  } else if (case_id == 3) {
    bound_3(U, dx, dy);
  } else if (case_id == 4) {
    bound_4(U);
  } else if (case_id == 5) {
    bound_5(U);
  } else if (case_id == 6) {
    bound_6(U);
  } else {
    printf("Wrong case id! Please choose case from [1,3-5]\n");
    exit(0);
  }
}

//求符号函数
//出口:大于零返回1,小于零返回-1,等于零返回0
double sign(double va) {
  if (va > 0) {
    return 1;
  }
  if (va < 0) {
    return -1;
  } else {
    return 0;
  }
}
//返回3个数中的较少者
double MIN3(double a1, double a2, double a3) {
  double re;
  if (a1 <= a2 && a1 <= a3)
    re = a1;
  else {
    if (a2 <= a3 && a2 <= a1)
      re = a2;
    else
      re = a3;
  }
  return re;
}
// minmod
double minmod(double w1, double w2) {
  double result;
  if (w1 * w2 > 0) {
    result = sign(w1) * MIN(fabs(w1), fabs(w2));
  } else
    result = 0;
  return result;
}
//对称TVD中用到的3个数的minmod
double minmod3(double w1, double w2, double w3) {
  double result;
  if (w1 * w2 * w3 > 0) {
    result = sign(w1) * MIN3(fabs(w1), fabs(w2), fabs(w3));
  } else
    result = 0;
  return result;
}
//通过U求F
void U2F(double U[4], double F[4]) {
  double u, v, p, rou;
  rou = U[0];
  u = U[1] / U[0];
  v = U[2] / U[0];
  p = (GAMA - 1) * (U[3] - 0.5 * rou * (u * u + v * v));
  F[0] = rou * u;
  F[1] = rou * u * u + p;
  F[2] = rou * u * v;
  F[3] = (U[3] + p) * u;
}
void U2G(double U[4], double G[4]) {
  double u, v, p, rou;
  rou = U[0];
  u = U[1] / U[0];
  v = U[2] / U[0];
  p = (GAMA - 1) * (U[3] - 0.5 * rou * (u * u + v * v));
  G[0] = rou * v;
  G[1] = rou * u * v;
  G[2] = rou * v * v + p;
  G[3] = (U[3] + p) * v;
}

void virtual_clear(double U[Nx + 7][Ny + 7][4], double dx, double dy) {
  int i, j, k;
  for (i = 3; i <= int(1.0 / dx) + 2; i++)  //为了显示正确,首先将虚拟节点赋0
    for (j = int(0.5 / dy) + 4; j <= int(0.5 / dy) + 6; j++)
      for (k = 0; k <= 3; k++) U[i][j][k] = 0;

  for (i = int(2.0 / dx) + 4; i <= Nx + 6; i++)
    for (j = int(0.5 / dy) + 4; j <= int(0.5 / dy) + 6; j++)
      for (k = 0; k <= 3; k++) U[i][j][k] = 0;

  for (i = int(1.0 / dx); i <= int(1.0 / dx) + 2; i++)
    for (j = int(0.5 / dy) + 4; j <= Ny + 6; j++)
      for (k = 0; k <= 3; k++) U[i][j][k] = 0;

  for (i = int(2.0 / dx) + 4; i <= int(2.0 / dx) + 6; i++)
    for (j = int(0.5 / dy) + 4; j <= Ny + 6; j++)
      for (k = 0; k <= 3; k++) U[i][j][k] = 0;
}

struct timer {
  std::unordered_map<const char*, double> elapsed_time_ms;
  std::unordered_map<const char*, int> count;
  std::unordered_map<const char*, timeval> time_point;

  void start(const char* func) {
    timeval s;
    gettimeofday(&s, NULL);
    time_point[func] = s;
  }
  void stop(const char* func) {
    timeval e;
    gettimeofday(&e, NULL);
    count[func]++;
    timeval s = time_point[func];
    elapsed_time_ms[func] += get_elapsed_time_ms(s, e);
  }
  void show_all() {
    for (auto it = elapsed_time_ms.begin(); it != elapsed_time_ms.end(); ++it) {
      auto func = it->first;
      double t = it->second;
      int c = count[func];
      printf("%s: %lf ms / %d count, avg %lf ms\n", func, t, c, t / c);
    }
  }
};

#endif